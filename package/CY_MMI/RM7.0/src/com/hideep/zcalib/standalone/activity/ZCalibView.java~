package com.hideep.zcalib.standalone.activity;

import java.text.DecimalFormat;
import java.util.ArrayList;

import com.hideep.zcalib.standalone.api.ZCalib;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

/*****************************************************************************
 * ZCalibView.java - ZCalib Application Example
 * Copyright (c) 2013-2017 HiDeep, Incorporated. All rights reserved.
 * Software License Agreement
 *   
 * HiDeep, Inc. is supplying this software for Gionee's own development on Gionee's 
 * own application software solely and exclusively for Gionee's own products that 
 * HiDeep's IC is used. HiDeep, Inc. is the owner of all intellectual property rights 
 * in this software and the right is protected under applicable laws.  
 *****************************************************************************/
public class ZCalibView extends View
{
	// Count of grid
	private static final int ZCALIB_GRID_GOUNT_X = 3;
	private static final int ZCALIB_GRID_GOUNT_Y = 5;
	
	// Size of grid line
	private static final int ZCALIB_GRID_WIDTH = 4;
	
	// Size of grid number
	private static final int ZCALIB_GRID_NUMBER_TEXT11 = 50;
	private static final int ZCALIB_GRID_NUMBER_TEXT12 = 130;
	private static final int ZCALIB_GRID_NUMBER_TEXT21 = 60;
	private static final int ZCALIB_GRID_NUMBER_TEXT22 = 140;
	private static final int ZCALIB_GRID_NUMBER_TEXT31 = 70;
	private static final int ZCALIB_GRID_NUMBER_TEXT32 = 150;
	
	private static final int MAX_TOUCH_NUM = 2;
	private static final int CIRCLE_SIZE_BORDER = 80;
	private static final float DRAW_TEXT_SIZE = 90;
	
	private static final float DRAW_TEXT_PROC_SIZE = 220;
	private static final int DRAW_TEXT_RESULT_GRID = 50;
	private static final int DRAW_TEXT_SPEC_VALUE_RESULT_GRID = 30;
	
	private static final int TOUCH_DOWN_FLAG = 1;
	private static final int TOUCH_UP_FLAG = 2;
	private static final int TOUCH_MOVE_FLAG = 3;

	private float m_CircleRatio = 1.F;
	private float m_Pressure;
	private float m_Pressure_z;
	
	private int[] m_PrevCircle = null;
	private float[] m_CircleX = null;
	private float[] m_CircleY = null;
	private float[] m_CircleSize = null;
	private PressSensor m_PSensor;
	// private Typeface m_Face;

	private Paint m_PaintGrid = new Paint();
	private Paint m_PaintCheckedGridRect = new Paint();
	private Paint m_PainTextNumber11 = new Paint();
	private Paint m_PainTextNumber12 = new Paint();
	private Paint m_PainTextNumber21 = new Paint();
	private Paint m_PainTextNumber22 = new Paint();
	private Paint m_PainTextNumber31 = new Paint();
	private Paint m_PainTextNumber32 = new Paint();
	
	private Paint m_PainTextNumber51 = new Paint();

	private Paint[] m_PressureCirclePaint = new Paint[5];
	private Paint m_PaintText1 = new Paint();
	private Paint m_PaintText2 = new Paint();
	private Paint m_PaintNGText = new Paint();
	private Paint m_PaintCONNText = new Paint();
	private Paint m_PaintPASSText = new Paint();
	private Paint m_PaintWAITText = new Paint();
	
	private Paint m_PaintGridPASSText = new Paint();
	private Paint m_PaintGridNGText = new Paint();
	private Paint m_PaintGridSpecValueText = new Paint();
	
	private Paint m_PaintGridRect1 = new Paint();
	private Paint m_PaintGridRect2 = new Paint();
	private Paint m_PaintGridRect3 = new Paint();
	private Paint m_PaintGridRect5 = new Paint();
	
	private int m_ScreenX = 0;
	private int m_ScreenY = 0;
	
	private OnTouchEventListener onTouchEventListener = null;
	
	private ArrayList<Integer> m_ListTouchNumber = new ArrayList<Integer>();	
	private ArrayList<Integer> m_ListAfterTouchNumber = new ArrayList<Integer>();
	
	private int m_ZValueDisplayLocationY = 180;
	private int m_ZValueDisplayLocationY_Bottom = 1920 - 300;
	
	private int m_ZCalibPointCount = 0;
	private int m_ZCalibVerifyPointCount = 0;
	
	private ViewActivity m_ViewActivity = null;
	private ArrayList<Boolean> m_CurrentGUICalPointFinishStatus;
	private int m_CurrentGUICalPoint;
	
	private float m_CurrentX = 0;
	private float m_CurrentY = 0;
	private ArrayList<float[]> m_VerifyPointXYPosition = null;
	
	private float m_SpecValue = 0.F;
	private int m_SpecRange = -1;
	private String m_NGMsg = "";
	private Paint m_PaintNGDebugText = new Paint();
	
	public ZCalibView(Context context)
	{
		super(context);
		this.Init(context);
	}
	
	public void setZCalibPointCount(int p, int p2)
	{
		this.m_ZCalibPointCount = p;
		this.m_ZCalibVerifyPointCount = p2;
		for (int i = 0 ; i < this.m_ZCalibPointCount ; i++)
		{
			this.m_CurrentGUICalPointFinishStatus.add(false);
			this.m_VerifyPointXYPosition.add(new float[]{0.F, 0.F});
		}
		this.m_CurrentGUICalPoint = 0;
	}

	/**
	 * @param context
	 * @param attrs
	 */
	public ZCalibView(Context context, AttributeSet attrs)
	{
		this(context, attrs, 0);
		this.Init(context);
	}

	/**
	 * @param context
	 * @param attrs
	 * @param defStyle
	 */
	public ZCalibView(Context context, AttributeSet attrs, int defStyle)
	{
		super(context, attrs, defStyle);
		this.Init(context);
	}
	
	public void setSpecValue(float f, int t, String m)
	{
		this.m_SpecValue = f;
		this.m_SpecRange = t;
		this.m_NGMsg = m;
	}

	/**
	 * Set ratio of pressure circle
	 * @param ratio
	 */
	public void SetCircleRatio(float ratio)
	{
		this.m_CircleRatio = ratio;
	}
	
	public void initViewActivity(ViewActivity v)
	{
		this.m_ViewActivity = v;
	}

	/**
	 * Init paint instance
	 */
	private void InitPaint()
	{
		// Grid paint
		this.m_PaintGrid.setColor(Color.BLACK);
		this.m_PaintGrid.setStrokeWidth(ZCALIB_GRID_WIDTH);
		this.m_PaintGrid.setStyle(Paint.Style.STROKE);
		
		// Grid complected rect
		this.m_PaintGridRect1.setColor(Color.WHITE);
		this.m_PaintGridRect1.setStrokeWidth(ZCALIB_GRID_WIDTH);
		this.m_PaintGridRect1.setAntiAlias(true);
		this.m_PaintGridRect1.setAlpha(70);
		
		this.m_PaintGridRect2.setColor(Color.GREEN);
		this.m_PaintGridRect2.setStrokeWidth(ZCALIB_GRID_WIDTH);
		this.m_PaintGridRect2.setAntiAlias(true);
		this.m_PaintGridRect2.setAlpha(70);

		this.m_PaintGridRect5.setColor(Color.BLUE);
		this.m_PaintGridRect5.setStrokeWidth(ZCALIB_GRID_WIDTH);
		this.m_PaintGridRect5.setAntiAlias(true);
		this.m_PaintGridRect5.setAlpha(70);
		
		this.m_PaintGridRect3.setColor(Color.DKGRAY);
		this.m_PaintGridRect3.setStrokeWidth(ZCALIB_GRID_WIDTH);
		this.m_PaintGridRect3.setAntiAlias(true);
		this.m_PaintGridRect3.setAlpha(80);
		
		// Grid checked paint
		this.m_PaintCheckedGridRect.setColor(Color.RED);
		this.m_PaintCheckedGridRect.setStrokeWidth(3);
		
		// Grid number 1~2
		this.m_PainTextNumber11.setAntiAlias(true);
		this.m_PainTextNumber11.setColor(Color.BLACK);
		this.m_PainTextNumber11.setTextSize(ZCALIB_GRID_NUMBER_TEXT11);
		this.m_PainTextNumber12.setAntiAlias(true);
		this.m_PainTextNumber12.setColor(Color.BLACK);
		this.m_PainTextNumber12.setTextSize(ZCALIB_GRID_NUMBER_TEXT12);
		
		this.m_PainTextNumber21.setAntiAlias(true);
		this.m_PainTextNumber21.setColor(Color.BLUE);
		this.m_PainTextNumber21.setTextSize(ZCALIB_GRID_NUMBER_TEXT21);
		this.m_PainTextNumber22.setAntiAlias(true);
		this.m_PainTextNumber22.setColor(Color.BLUE);
		this.m_PainTextNumber22.setTextSize(ZCALIB_GRID_NUMBER_TEXT22);
		
		this.m_PainTextNumber31.setAntiAlias(true);
		this.m_PainTextNumber31.setColor(Color.RED);
		this.m_PainTextNumber31.setTextSize(ZCALIB_GRID_NUMBER_TEXT31);
		this.m_PainTextNumber32.setAntiAlias(true);
		this.m_PainTextNumber32.setColor(Color.RED);
		this.m_PainTextNumber32.setTextSize(ZCALIB_GRID_NUMBER_TEXT32);
		
		this.m_PainTextNumber51.setAntiAlias(true);
		this.m_PainTextNumber51.setColor(Color.RED);
		this.m_PainTextNumber51.setTextSize(ZCALIB_GRID_NUMBER_TEXT32);
		
		// Pressured circle
		this.m_CircleX = new float[MAX_TOUCH_NUM];
		this.m_CircleY = new float[MAX_TOUCH_NUM];
		this.m_CircleSize = new float[MAX_TOUCH_NUM];
		this.m_PSensor = new PressSensor();

		for (int i = 0; i < this.m_PressureCirclePaint.length; i++)
		{
			this.m_PressureCirclePaint[i] = new Paint();
			this.m_PressureCirclePaint[i].setAntiAlias(true);
		}

		this.m_PressureCirclePaint[0].setColor(Color.rgb(255, 255, 204));
		this.m_PressureCirclePaint[1].setColor(Color.rgb(255, 204, 153));
		this.m_PressureCirclePaint[2].setColor(Color.rgb(255, 153, 102));
		this.m_PressureCirclePaint[3].setColor(Color.rgb(255, 102, 0));
		this.m_PressureCirclePaint[4].setColor(Color.rgb(255, 0, 0));
		
		this.m_PaintText1.setAntiAlias(true);
		this.m_PaintText1.setColor(Color.BLACK);
		this.m_PaintText1.setTextSize(DRAW_TEXT_SIZE);
		
		this.m_PaintText2.setAntiAlias(true);
		this.m_PaintText2.setColor(Color.BLUE);
		this.m_PaintText2.setTextSize(DRAW_TEXT_SIZE);
		
		this.m_PaintNGDebugText.setAntiAlias(true);
		this.m_PaintNGDebugText.setColor(Color.BLUE);
		this.m_PaintNGDebugText.setTextSize(DRAW_TEXT_SIZE - 30);
		
		this.m_PaintNGText.setAntiAlias(true);
		this.m_PaintNGText.setColor(Color.RED);
		this.m_PaintNGText.setTextSize(DRAW_TEXT_PROC_SIZE);
		
		this.m_PaintCONNText.setAntiAlias(true);
		this.m_PaintCONNText.setColor(Color.RED);
		this.m_PaintCONNText.setTextSize(DRAW_TEXT_PROC_SIZE - 160);

		this.m_PaintPASSText.setAntiAlias(true);
		this.m_PaintPASSText.setColor(Color.BLUE);
		this.m_PaintPASSText.setTextSize(DRAW_TEXT_PROC_SIZE);

		this.m_PaintWAITText.setAntiAlias(true);
		this.m_PaintWAITText.setColor(Color.DKGRAY);
		this.m_PaintWAITText.setTextSize(DRAW_TEXT_PROC_SIZE);
		
		this.m_PaintGridPASSText.setAntiAlias(true);
		this.m_PaintGridPASSText.setColor(Color.BLUE);
		this.m_PaintGridPASSText.setTextSize(DRAW_TEXT_RESULT_GRID);
		
		this.m_PaintGridNGText.setAntiAlias(true);
		this.m_PaintGridNGText.setColor(Color.RED);
		this.m_PaintGridNGText.setTextSize(DRAW_TEXT_RESULT_GRID);
		
		this.m_PaintGridSpecValueText.setAntiAlias(true);
		this.m_PaintGridSpecValueText.setColor(Color.BLACK);
		this.m_PaintGridSpecValueText.setTextSize(DRAW_TEXT_SPEC_VALUE_RESULT_GRID);
	}

	/**
	 * Init
	 * @param context
	 */
	private void Init(Context context)
	{
		this.InitPaint();
		this.InitValue();
		
	}
	
	public void InitValue()
	{
		this.m_PrevCircle = new int[MAX_TOUCH_NUM];
		this.m_CurrentGUICalPointFinishStatus = new ArrayList<Boolean>();
		this.m_VerifyPointXYPosition = new ArrayList<float[]>();
	}

	public void setPressure_Z(float m_Pressure_Z) { this.m_Pressure_z = m_Pressure_Z; }
	public float getPressure_Z() { return this.m_Pressure_z;}	

	public interface OnTouchEventListener
	{
		void onDownEvent(int flag, int id, float  x, float  y, float pressure, int count);
		void onUpEvent(int flag, int id, float x, float  y, float pressure, int count);
		void onMoveEvent(int flag, int id, float x, float y, float pressure, int count);
	}
	
	public void OnTouchEventListener(OnTouchEventListener listener) {
		this.onTouchEventListener = listener;
	}
	
	public void setInitListTouchNumber()
	{
		this.m_ListTouchNumber = new ArrayList<Integer>();
	}
	public void setInitListAfterTouchNumber()
	{
		this.m_ListAfterTouchNumber = new ArrayList<Integer>();
	}
	public void setCurrentGUICalPoint(int p)
	{
		this.m_CurrentGUICalPoint = p;
	}

	/**
	 * Draw pressure circle
	 * @param canvas
	 */
	private void onDrawCircle(Canvas canvas)
	{
		for (int pressId = 0; pressId < this.m_PSensor.getPressLenth(); pressId++)
		{
			if (this.m_PSensor.getPress(pressId))
			{
				int thisCircle = 0;
				for (int i = 0; i < this.m_PressureCirclePaint.length; i++)
				{
					float drawCircleSize = (this.m_CircleSize[pressId] - i * CIRCLE_SIZE_BORDER);
					if (drawCircleSize > 0)
					{
						canvas.drawCircle(this.m_CircleX[pressId], this.m_CircleY[pressId], drawCircleSize, this.m_PressureCirclePaint[i]);
						thisCircle = thisCircle < i ? i : thisCircle;
					}
				}
				this.m_PrevCircle[pressId] = thisCircle;
			}
		}
	}
	
	/**
	 * Draw pressure info.
	 * @param canvas
	 */
	@SuppressLint("DefaultLocale")
	private void onDrawText(Canvas canvas)
	{
		for (int pressId = 0; pressId < this.m_PSensor.getPressLenth(); pressId++)
		{
			if (this.m_PSensor.getPress(pressId))
			{
				float num = this.getPressure_Z();
				DecimalFormat df = new DecimalFormat("#,##0");
				String tmpPrs = df.format(num);
				String strNum = String.format("%.2f", this.m_Pressure);
				if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
				{
					strNum = tmpPrs;
				}
				else
				{
					strNum = strNum + " (" + tmpPrs + ")";
				}

				Rect bounds = new Rect();
				Paint tmpPaint = null;
				
				if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
				{
					tmpPaint = this.m_PaintText1;
				}
				else if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
				{
					tmpPaint = this.m_PaintText2;
				}
				else
				{
					tmpPaint = this.m_PaintText1;
				}

				tmpPaint.getTextBounds(strNum, 0, strNum.length(), bounds);
				float fX = (this.m_ScreenX / 2) - (bounds.width() / 2);
				float fY = this.m_ZValueDisplayLocationY;
				canvas.drawText(strNum, fX, fY, tmpPaint);
				
				tmpPaint.getTextBounds(strNum, 0, strNum.length(), bounds);
				fY = this.m_ZValueDisplayLocationY_Bottom;
				canvas.drawText(strNum, fX, fY, tmpPaint);
			}
		}
	}
	
	/**
	 * Display NG
	 * @param canvas
	 */
	private void onDrawNG(Canvas canvas)
	{
		String strNG = "NG";
		Rect bounds = new Rect();
		float fX = this.m_ScreenX / 2;
		float fY = this.m_ScreenY / 2;
		this.m_PaintNGText.getTextBounds(strNG, 0, strNG.length(), bounds);
		canvas.drawText(strNG, fX - (bounds.width() / 2), fY, this.m_PaintNGText);

		String r0 = "";
		if (this.m_SpecRange == 0) { r0 = " SPEC. ก่"; }
		else if (this.m_SpecRange == 1) { r0 = " SPEC. ก้"; }
		else if (this.m_SpecRange >= 2)
		{
			r0 = this.m_NGMsg;
		}
		
		String txt = "";
		if (this.m_SpecRange == 0 || this.m_SpecRange == 1)
		{
			txt = "PRS: " + String.format("%.2f", this.m_SpecValue) + ", " + r0;
		}
		else if (this.m_SpecRange >= 2)
		{
			txt = r0;
		}
		
		if (this.m_SpecRange >= 0)
		{
			Rect bounds2 = new Rect();
			this.m_PaintNGDebugText.getTextBounds(txt, 0, txt.length(), bounds2);
			canvas.drawText(txt, fX - (bounds2.width() / 2), fY - 500, this.m_PaintNGDebugText);
		}
	}
	
	/**
	 * Display ERROR C/D
	 * @param canvas
	 */
	private void onDrawERROR_CONN(Canvas canvas)
	{
		String strNG = "CONNECTION ERROR";
		Rect bounds = new Rect();
		float fX = this.m_ScreenX / 2;
		float fY = this.m_ScreenY / 2;
		this.m_PaintCONNText.getTextBounds(strNG, 0, strNG.length(), bounds);
		canvas.drawText(strNG, fX - (bounds.width() / 2), fY, this.m_PaintCONNText);
		
		strNG = "for char device";
		fY = this.m_ScreenY / 2 + 110;
		this.m_PaintCONNText.getTextBounds(strNG, 0, strNG.length(), bounds);
		canvas.drawText(strNG, fX - (bounds.width() / 2), fY, this.m_PaintCONNText);
	}
	
	/**
	 * Display PASS
	 * @param canvas
	 */
	private void onDrawPASS(Canvas canvas)
	{
		String strNG = "PASS";
		Rect bounds = new Rect();
		float fX = this.m_ScreenX / 2;
		float fY = this.m_ScreenY / 2;
		this.m_PaintPASSText.getTextBounds(strNG, 0, strNG.length(), bounds);
		canvas.drawText(strNG, fX - (bounds.width() / 2), fY, this.m_PaintPASSText);
	}

	/**
	 * Touch up
	 * @param id
	 */
	private void TouchUp(int flag, float x, float y, float pressure, int id, int count)
	{
		if (id < MAX_TOUCH_NUM)
		{
			this.m_PSensor.setPress(id, false);
			this.m_PrevCircle[id] = 0;

			onTouchEventListener.onUpEvent(flag, id, x, y, pressure, count);
			invalidate();
		}
	}
	
	/**
	 * Touch down
	 * @param flag
	 * @param x
	 * @param y
	 * @param z
	 * @param id
	 */
	private void TouchDown(int flag, float x, float y, float z, int id, int count)
	{
		this.m_CircleX[id] = x;
		this.m_CircleY[id] = y;
		this.m_PSensor.setPress(id, true);

		this.m_CircleSize[id] = this.m_PSensor.getCircleSize(z);
		onTouchEventListener.onDownEvent(flag, id, x, y, z, count);		
		invalidate();
	}
	
	/**
	 * Touch move
	 * @param x
	 * @param y
	 * @param z
	 * @param id
	 */
	private void TouchMove(int flag, float x, float y, float z, int id, int count)
	{
		this.m_CircleX[id] = x;
		this.m_CircleY[id] = y;
		this.m_PSensor.setPress(id, true);

		this.m_CircleSize[id] = this.m_PSensor.getCircleSize(z);		
		onTouchEventListener.onMoveEvent(flag, id, x, y, z, count);
		invalidate();
	}

	/**
	 * OnMeasure
	 */
	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
	{
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
		this.m_ScreenX = this.getWidth();
		this.m_ScreenY = this.getHeight();
	}

	/**
	 * OnDraw
	 */
	@Override
	protected void onDraw(Canvas canvas)
	{
		// Set pressure circle
		this.onDrawCircle(canvas);
		
		if (this.m_ViewActivity.getCurrentZCalibStatus() != ZCalib.STATUS_CURRENT_RESULT &&
			this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
		{
			// Set grid lines (modifiy 2015.08.15)
			// this.SetGridLine(canvas);
			
			// Set grid numbers
			this.SetGridNumber(canvas);

			// Set completed rect
			this.SetCompleteRect(canvas);
		}

		if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT &&
			this.m_ViewActivity.getCurrentZCalibStatus() != ZCalib.STATUS_CURRENT_RESULT)
		{
			this.SetDrawVerifyNumber(canvas);
			this.SetCompleteRect(canvas);
			this.SetSpecResult(canvas);
		}
		
		if (this.m_ViewActivity.getCurrentZCalibVerifyStstus() == ZCalib.RESULT_PASS)
		{
			this.onDrawPASS(canvas);
		}
		if (this.m_ViewActivity.getCurrentZCalibVerifyStstus() == ZCalib.RESULT_NG)
		{
			this.onDrawNG(canvas);
			if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_RESULT)
			{
				this.SetSpecResult(canvas);
			}
		}
	
		if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_ERROR)
		{
			this.onDrawERROR_CONN(canvas);
		}
		
		// Set pressured values
		this.onDrawText(canvas);
	}
	
	/**
	 * Check screen status
	 * @return
	 */
	private boolean CheckScreen()
	{
		if (this.m_ScreenX > 0 && this.m_ScreenY > 0) { return true; }
		else { return false; }
	}
	
	/**
	 * Draw grid lines
	 */
	private void SetGridLine(Canvas canvas)
	{
		/** to comment
		if (this.CheckScreen() == true)
		{
			float hgridMargin = (this.m_ScreenX) / ZCALIB_GRID_GOUNT_X;
			float vgridMargin = (this.m_ScreenY) / ZCALIB_GRID_GOUNT_Y;
			
			for (int i = 0 ; i <= ZCALIB_GRID_GOUNT_X ; i++)
			{
				canvas.drawLine(	(float)(i * hgridMargin) + (ZCALIB_GRID_WIDTH / 2), 
										(float)0, 
										(float)(i * hgridMargin) + (ZCALIB_GRID_WIDTH / 2), 
										(float)this.m_ScreenY,
										this.m_PaintGrid);
			}

			for (int i = 0; i <= ZCALIB_GRID_GOUNT_Y ; i++)
			{
				canvas.drawLine(	0, 
										(float)(i * vgridMargin) + 2,
										(float)this.m_ScreenX, 
										(float)(i * vgridMargin) + 2, 
										this.m_PaintGrid);
			}
		}
		*/
	}
	
	/**
	 * Draw grid lines
	 */
	private void SetCompleteRect(Canvas canvas)
	{
		if (this.CheckScreen() == true)
		{
			float hgridMargin = this.m_ScreenX / ZCALIB_GRID_GOUNT_X;
			float vgridMargin = this.m_ScreenY / ZCALIB_GRID_GOUNT_Y;
			
			int k = 0;
			Paint tmpPaintRect = new Paint();
			for (int i = 0 ; i < ZCALIB_GRID_GOUNT_Y ; i++)
			{
				for (int j = 0 ; j < ZCALIB_GRID_GOUNT_X ; j++)
				{
					if (k == this.m_CurrentGUICalPoint)
					{
						// Text grid number
						tmpPaintRect = this.m_PaintGridRect1;
						if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
						{
							if (this.m_ViewActivity.getCurrentZCalibGetteringStatus() == ZCalib.STATUS_GETTERING_CAL_VALUE_SAVE_START)
							{
								tmpPaintRect = this.m_PaintGridRect2;
							}
							else if (this.m_ViewActivity.getCurrentZCalibGetteringStatus() == ZCalib.STATUS_GETTERING_CAL_VALUE_SAVE_FINISH)
							{
								tmpPaintRect = this.m_PaintGridRect5;
							}
							else
							{
								tmpPaintRect = this.m_PaintGridRect1;
							}
						}
						else if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
						{
							if (this.m_ViewActivity.getCurrentZCalibGetteringStatus() == ZCalib.STATUS_GETTERING_CAL_VALUE_SAVE_START)
							{
								tmpPaintRect = this.m_PaintGridRect2;
							}
							else if (this.m_ViewActivity.getCurrentZCalibGetteringStatus() == ZCalib.STATUS_GETTERING_CAL_VALUE_SAVE_FINISH)
							{
								tmpPaintRect = this.m_PaintGridRect5;
							}
							else
							{
								tmpPaintRect = this.m_PaintGridRect1;
							}
						}
						else
						{
							tmpPaintRect = this.m_PaintGridRect1;	
						}
					}
					else if (this.m_CurrentGUICalPoint < k)
					{
						if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
						{
							tmpPaintRect = this.m_PaintGridRect1;
						}
					}
					else
					{
						if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
						{
							tmpPaintRect = this.m_PaintGridRect5;
						}
					}
					
					if (tmpPaintRect != null)
					{
						if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
						{							
							canvas.drawRect((float)j * hgridMargin + 1,
													(float)i * vgridMargin + 1,
													(float)(j + 1) * hgridMargin - 1,
													(float)(i + 1) * vgridMargin - 1,
													tmpPaintRect);
						}
						else if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
						{
							if (k == this.m_CurrentGUICalPoint)
							{
								canvas.drawRect(0,
														0,
														this.m_ScreenX,
														this.m_ScreenY,
														tmpPaintRect);
							}
						}
					}
					k++;
				}
			}
		}
	}
	
	/**
	 * Draw Spec. result
	 * @param canvas
	 */
	private void SetSpecResult(Canvas canvas)
	{
		String strSpecResult = "";
		String strSpecValue = "";
		Paint tmpPaint = new Paint();

		Rect bounds = new Rect();
		Rect bounds2 = new Rect();

		// verify points
		if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
		{
			this.m_VerifyPointXYPosition.set(this.m_ViewActivity.getCurrentZCalibPointIdx(), new float[]{this.m_CurrentX, this.m_CurrentY});
		}
		
		for (int i = 0 ; i < this.m_ZCalibVerifyPointCount ; i++)
		{
			if ((this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT && i < this.m_CurrentGUICalPoint) ||
				this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_RESULT && 
				(this.m_CurrentGUICalPoint + 1) == this.m_ZCalibVerifyPointCount)
			{
				try
				{
					int tmp = this.m_ViewActivity.getZCalibVerificationResultArray(i);
					if (tmp == ZCalib.RESULT_PASS)
					{
						strSpecResult = "PASS";
						tmpPaint = this.m_PaintGridPASSText;
					}
					else if (tmp == ZCalib.RESULT_NG)
					{
						strSpecResult = "NG";
						tmpPaint = this.m_PaintGridNGText;
					}
					
					if (tmp == ZCalib.RESULT_PASS || tmp == ZCalib.RESULT_NG)
					{
						this.m_PaintGridNGText.getTextBounds(strSpecResult, 0, strSpecResult.length(), bounds);
						canvas.drawText(strSpecResult, 
												m_VerifyPointXYPosition.get(i)[0], 
												m_VerifyPointXYPosition.get(i)[1], 
												tmpPaint);
						
						if (tmp == ZCalib.RESULT_NG)
						{
							DecimalFormat df = new DecimalFormat("0.00");
							strSpecValue = "" + df.format(this.m_ViewActivity.getZCalibVerificationSpecResultArray(i)) + "%";
							this.m_PaintGridSpecValueText.getTextBounds(strSpecValue, 0, strSpecValue.length(), bounds2);
							canvas.drawText(strSpecValue, 
													m_VerifyPointXYPosition.get(i)[0], 
													m_VerifyPointXYPosition.get(i)[1] + 30, 
													this.m_PaintGridSpecValueText);
						}
					}
				}
				catch (ArrayIndexOutOfBoundsException e)
				{
					e.printStackTrace();
				}
				catch (IndexOutOfBoundsException e)
				{
					e.printStackTrace();
				}
			}
		}
	}
	
	/**
	 * Verify number (CurrentNum / TotalNum)
	 * @param canvas
	 */
	private void SetDrawVerifyNumber(Canvas canvas)
	{
		String str = "";
		Rect bounds = new Rect();
		
		str = (this.m_CurrentGUICalPoint + 1) + " / " + this.m_ZCalibVerifyPointCount;
		this.m_PainTextNumber51.getTextBounds(str, 0, str.length(), bounds);
		float fX = (this.m_ScreenX / 2) - (bounds.width() / 2);
		float fY =  (this.m_ScreenY / 2) - (bounds.height() / 2);

		canvas.drawText(str, 
								fX, 
								fY, 
								this.m_PainTextNumber51);
	}
	
	/**
	 * Draw grid numbers
	 * @param canvas
	 */
	private void SetGridNumber(Canvas canvas)
	{
		if (this.CheckScreen() == true)
		{
			float hgridMargin = this.m_ScreenX / ZCALIB_GRID_GOUNT_X;
			float vgridMargin = this.m_ScreenY / ZCALIB_GRID_GOUNT_Y;
			
			int k = 0;
			int nCount = 0;
			String strConvCount;

			Rect bounds = new Rect();
			Rect rect = new Rect();
			Paint tmpPaint = new Paint();

			for (int i = 0 ; i < ZCALIB_GRID_GOUNT_Y ; i++)
			{
				for (int j = 0 ; j < ZCALIB_GRID_GOUNT_X ; j++)
				{
					strConvCount = Integer.toString(++nCount);
					rect.left = (int)(j * hgridMargin);
					rect.bottom = (int)(i * vgridMargin);
					rect.right = (int)(j * hgridMargin + hgridMargin);
					rect.top = (int)(i * vgridMargin + vgridMargin) ;
					
					if (k == this.m_CurrentGUICalPoint)
					{
						tmpPaint = this.m_PainTextNumber32;
					}
					else if (this.m_CurrentGUICalPoint >= k)
					{
						if (k > this.m_CurrentGUICalPoint + 1)
						{
							tmpPaint = this.m_PainTextNumber32;
						}
						else
						{
							tmpPaint = this.m_PainTextNumber21;
						}
					}
					else
					{
						tmpPaint = this.m_PainTextNumber11;
					}
					
					if (tmpPaint != null)
					{
						if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT ||
							this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
						{	
							// Number
							// if (this.m_ZCalibValues.getZCalibSpecResult(nCount - 1) == 0)
							// {
								tmpPaint.getTextBounds(strConvCount, 0, strConvCount.length(), bounds);
								canvas.drawText(strConvCount, 
														(float)((j * hgridMargin) + (hgridMargin / 2) - (bounds.width()/2.)) , 
														(float)((i * vgridMargin) + (vgridMargin / 2) + (bounds.height() / 2.)), 
														tmpPaint);
							// }
						}
					}
					k++;
				}
			}
		}
	}
	
	/**
	 * Check number
	 * @param nCount
	 * @param canvas
	 * @param rect
	 */
	/*
	private void drawCheckedNumber(int nCount, Canvas canvas, Rect rect)
	{		
		if(this.m_ListTouchNumber.contains(nCount) == true)
		{
			canvas.drawLine(rect.left, rect.top, rect.right, rect.bottom, this.m_PaintCheckedGridRect);
			canvas.drawLine(rect.left, rect.bottom, rect.right, rect.top, this.m_PaintCheckedGridRect);
		}		
	}
	*/
	
	/**
	 * Search touched number
	 * @param x
	 * @param y
	 * @return
	 */
	public int SearchTouchedNumber(float x, float y)
	{
		float x0 = (x / (int)(this.m_ScreenX / ZCALIB_GRID_GOUNT_X));
		float y0 = (y / (int)(this.m_ScreenY / ZCALIB_GRID_GOUNT_Y));
		return ((int)y0 * (int)ZCALIB_GRID_GOUNT_X) + ((int)x0 + 1);
	}
	
	/**
	 * TouchEvent
	 */
	@SuppressLint("ClickableViewAccessibility")
	@Override
	public boolean onTouchEvent(MotionEvent event)
	{
		float x = event.getX();
		float y = event.getY();
		float z = event.getPressure() * this.m_CircleRatio;
		
		this.m_CurrentX = x;
		this.m_CurrentY = y;
		this.m_Pressure = z;

		int pointer_index = event.getActionIndex();
		int touchId = event.getPointerId(pointer_index);
		int touchCount = event.getPointerCount();
		
		switch (event.getAction() & MotionEvent.ACTION_MASK)
		{
			case MotionEvent.ACTION_DOWN:
			{
				touchId = event.getPointerId(0);
				this.TouchDown(TOUCH_DOWN_FLAG, x, y, z, touchId, touchCount);
				break;
			}
	
			case MotionEvent.ACTION_MOVE:
			{
				// int maxCnt = event.getPointerCount() >= MAX_TOUCH_NUM ? MAX_TOUCH_NUM : event.getPointerCount();
				int totalPress = 0;
	
				for (int i = 0; i < MAX_TOUCH_NUM ; i++)
				{
					totalPress = this.m_PSensor.getPress(i) ? totalPress + 1 : totalPress;
				}

				if (totalPress < 1) { break; }
				
				x = event.getX();
				y = event.getY();
				touchId = event.getPointerId(0);
				this.TouchMove(TOUCH_MOVE_FLAG, x, y, z, touchId, touchCount);
	
				break;
			}
	
			case MotionEvent.ACTION_UP:
			{
				pointer_index = event.getActionIndex();
				touchId = event.getPointerId(pointer_index);
		
				// int nCheckedNum = this.SearchTouchedNumber((int)event.getX(pointer_index), (int)event.getY(pointer_index));
				if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
				{
					int nCheckedNum = this.m_ViewActivity.getCurrentZCalibPointIdx();
					if(this.m_ListTouchNumber.contains(nCheckedNum + 1) == false)
					{
						this.m_ListTouchNumber.add(nCheckedNum + 1);
					}
				}
				else if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
				{
					int nCheckedNum = this.m_ViewActivity.getCurrentZCalibPointIdx();
					if(this.m_ListAfterTouchNumber.contains(nCheckedNum + 1) == false)
					{
						this.m_ListAfterTouchNumber.add(nCheckedNum + 1);
					}
				}
				
				if (touchId < MAX_TOUCH_NUM)
				{
					this.TouchUp(TOUCH_UP_FLAG, x, y, z, touchId, touchCount);
				}
				break;
			}
	
			case MotionEvent.ACTION_POINTER_UP:
			{
				// int nCheckedNum = this.SearchTouchedNumber((int)event.getX(pointer_index), (int)event.getY(pointer_index));
				if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_CAL_POINT)
				{
					int nCheckedNum = this.m_ViewActivity.getCurrentZCalibPointIdx();
					if(this.m_ListTouchNumber.contains(nCheckedNum + 1) == false)
					{
						this.m_ListTouchNumber.add(nCheckedNum + 1);
					}
				}
				else if (this.m_ViewActivity.getCurrentZCalibStatus() == ZCalib.STATUS_CURRENT_VERIFY_POINT)
				{
					int nCheckedNum = this.m_ViewActivity.getCurrentZCalibPointIdx();
					if(this.m_ListAfterTouchNumber.contains(nCheckedNum + 1) == false)
					{
						this.m_ListAfterTouchNumber.add(nCheckedNum + 1);
					}
				}
				
				if (touchId != MotionEvent.INVALID_POINTER_ID && touchId < MAX_TOUCH_NUM)
				{
					this.TouchUp(TOUCH_UP_FLAG, x, y, z, touchId, touchCount);
				}
				break;
			}
		}
		
		invalidate();
		return true;
	}

	@Override
	protected void onDetachedFromWindow()
	{
		super.onDetachedFromWindow();
	}
}
